"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _child_process = require("child_process");

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DOCKER_EVENTS_MODULE = _path.default.resolve(__dirname, '..', 'modules/dockerEvents');
/**
 * @class DockerEventsListener
 * @extends {EventEmitter}
 */


class DockerEventsListener extends _events.default {
  /**
   * @constructor
   * @param {Logger} [logger]
   */
  constructor(logger = console) {
    super();
    this.logger = logger;
    this._subprocess = null;
    this._onMessage = this._onMessage.bind(this);
    this._onError = this._onError.bind(this);
  }
  /**
   * @param {Object} opt Command line options for 'docker events'
   */


  connect(opt = {}) {
    this.disconnect();
    const sps = (0, _child_process.fork)(DOCKER_EVENTS_MODULE);
    sps.on('message', this._onMessage);
    sps.on('error', this._onError);
    sps.send(opt);
    this.logger.warn('Connecting dockerEventsListener:', sps.pid);
    this._subprocess = sps;
  }

  disconnect() {
    if (this._subprocess && this._subprocess.connected) {
      this.logger.warn('Disconnecting dockerEventsListener:', this._subprocess.pid);

      this._subprocess.disconnect();
    }

    this._subprocess = null;
  }
  /**
   * @param {Object} message Event JSON
   * @private
   */


  _onMessage(message) {
    if ('error' === message.type) {
      this._onError(new Error(message.message));

      return;
    }

    this.emit(message.type, message);
  }

  _onError(err) {
    this.logger.error(err);
    this.disconnect();
  }

}

var _default = DockerEventsListener;
exports.default = _default;